# Firefly Integration Guide

This guide explains how to use the Firefly CI agent to post-process Terragrunt logs captured by the wrapper script.

## Overview

The GitLab CI pipeline includes post-processing jobs that **automatically** send infrastructure logs to Firefly for analysis and monitoring. These jobs run after the plan and apply stages, processing the logs generated by the wrapper script for each module.

## Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Plan/Apply     ‚îÇ
‚îÇ  (with wrapper) ‚îÇ
‚îÇ                 ‚îÇ
‚îÇ  Creates logs:  ‚îÇ
‚îÇ  - init_log     ‚îÇ
‚îÇ  - plan_log     ‚îÇ
‚îÇ  - apply_log    ‚îÇ
‚îÇ  - plan_output  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Firefly Agent  ‚îÇ
‚îÇ                 ‚îÇ
‚îÇ  Processes logs ‚îÇ
‚îÇ  per module     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Firefly Cloud  ‚îÇ
‚îÇ  (Analysis &    ‚îÇ
‚îÇ   Monitoring)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Pipeline Stages

The pipeline includes two new stages:

1. **`post-plan`**: Processes plan logs after the `plan` stage
2. **`post-apply`**: Processes apply logs after the `apply` stage

### Post-Plan Jobs

- `post_plan_vpc`: Processes VPC module plan logs
- `post_plan_database`: Processes Database module plan logs

### Post-Apply Jobs

- `post_apply_vpc`: Processes VPC module apply logs
- `post_apply_database`: Processes Database module apply logs

## Prerequisites

- **Firefly Account**: With access key and secret key
- **GitLab CI/CD Variables**: Configured in your project settings

## Setup

### 1. Configure Firefly Credentials

The Firefly agent requires two credentials to be set as GitLab CI/CD variables:

1. Go to your GitLab project: **Settings > CI/CD > Variables**
2. Add the following **protected** and **masked** variables:
   - `FIREFLY_ACCESS_KEY`: Your Firefly access key
   - `FIREFLY_SECRET_KEY`: Your Firefly secret key

**Important**: Make sure to:
- ‚úÖ Check "Protect variable" (if using protected branches)
- ‚úÖ Check "Mask variable" (hides value in job logs)
- ‚ùå Do NOT check "Expand variable reference" (use raw values)

### 2. Set Terragrunt Verision

The Firefly agent requires the terragrunt version to be specified manually via an environment variable (for better tracking)

1. Ensure that the `TERRAGRUNT_VERSION` environment variable is set appropriately.

### 2. Verify Agent Setup

The pipeline downloads the Firefly CI binary directly:

```yaml
image: alpine:latest
before_script:
  - apk add --no-cache curl
  - curl -O https://gofirefly-prod-iac-ci-cli-binaries.s3.amazonaws.com/fireflyci/latest/fireflyci_Linux_x86_64.tar.gz
  - tar -xf fireflyci_Linux_x86_64.tar.gz
  - chmod +x fireflyci
  - mv fireflyci /usr/local/bin/
```

You can update the version tag in `.gitlab-ci.yml` if needed.

## Usage

### Automatic Post-Processing

Post-processing jobs run **automatically** with no manual intervention required:

1. **After Plan Stage**:
   - When `plan_all` completes successfully
   - Jobs `post_plan_vpc` and `post_plan_database` run automatically
   - Processes plan logs and sends them to Firefly

2. **After Apply Stage**:
   - When you manually trigger and `apply_all` completes successfully
   - Jobs `post_apply_vpc` and `post_apply_database` run automatically
   - Processes apply logs and updates Firefly inventory
   - **Note**: If you skip `apply_all`, post-apply jobs are also skipped (no logs to process)

### What Gets Processed

#### Post-Plan Processing

For each module, the agent sends:
- `plan_log.jsonl`: JSON-formatted plan execution log
- `plan_output.json`: Structured plan output
- `init_log.jsonl`: Initialization logs
- `plan_output_raw.log`: Human-readable plan output

**Command executed**:
```bash
fireflyci post-plan \
  -l plan_log.jsonl \
  -f plan_output.json \
  -i init_log.jsonl \
  --plan-output-raw-log-file plan_output_raw.log \
  --workspace "${CI_PROJECT_NAME}" \
  --environment "<module_name>" \
  --terragrunt-version "${TERRAGRUNT_VERSION}" \
  --access-key "${FIREFLY_ACCESS_KEY}" \
  --secret-key "${FIREFLY_SECRET_KEY}"
```

#### Post-Apply Processing

For each module, the agent sends:
- `apply_log.jsonl`: JSON-formatted apply execution log

**Command executed**:
```bash
fireflyci post-apply \
  -f apply_log.jsonl \
  --workspace "${CI_PROJECT_NAME}" \
  --environment "<module_name>" \
  --terragrunt-version "${TERRAGRUNT_VERSION}" \
  --access-key "${FIREFLY_ACCESS_KEY}" \
  --secret-key "${FIREFLY_SECRET_KEY}"
```

## Module-Specific Processing

The agent processes each module independently:

| Module   | Environment Tag | Processed Separately |
|----------|----------------|---------------------|
| vpc      | `vpc`          | ‚úÖ                  |
| database | `database`     | ‚úÖ                  |

This ensures that Firefly can:
- Track changes per environment/module
- Provide module-specific insights
- Maintain separate drift detection per module

## Advanced Configuration

### Changing the Workspace Name

By default, the workspace is set to `${CI_PROJECT_NAME}` (your GitLab project name). To customize:

```yaml
# In .gitlab-ci.yml, modify the --workspace flag:
--workspace "my-custom-workspace-name"
```

### Adding More Modules

To add post-processing for a new module (e.g., `network`):

1. Add new jobs in `.gitlab-ci.yml`:

```yaml
post_plan_network:
  <<: *firefly_agent
  stage: post-plan
  script:
    - echo "Processing plan logs for Network module..."
    - cd network
    - export TERRAGRUNT_VERSION=$(terragrunt --version 2>/dev/null | head -1 | awk '{print $3}' || echo "unknown")
    - |
      fireflyci post-plan \
        -l plan_log.jsonl \
        -f plan_output.json \
        -i init_log.jsonl \
        --plan-output-raw-log-file plan_output_raw.log \
        --workspace "${CI_PROJECT_NAME}" \
        --environment "network" \
        --terragrunt-version "${TERRAGRUNT_VERSION}"
    - echo "‚úì Post-plan processing completed for Network"
  dependencies:
    - plan_all
  only:
    - branches
    - merge_requests

post_apply_network:
  <<: *firefly_agent
  stage: post-apply
  script:
    - echo "Processing apply logs for Network module..."
    - cd network
    - |
      fireflyci post-apply \
        -f apply_log.jsonl \
        --workspace "${CI_PROJECT_NAME}" \
        --environment "network" \
        --terragrunt-version "${TERRAGRUNT_VERSION}"
    - echo "‚úì Post-apply processing completed for Network"
  dependencies:
    - apply_all
  only:
    - branches
    - merge_requests
  needs:
    - job: apply_all
      optional: false
  when: on_success
```

### Execution Model

**Current Configuration**: Jobs run **automatically** by default.

**Post-Plan Jobs**:
- Run immediately after `plan_all` succeeds

**Post-Apply Jobs**:
- Use `when: on_success` with `needs` dependencies
- Only run when `apply_all` actually executes and succeeds
- Automatically skipped if `apply_all` is not triggered

**To Make Jobs Manual** (if needed):
```yaml
# Add to any job:
  when: manual
```

### Dynamic Module Discovery

For a more dynamic approach, you could create a single job that discovers and processes all modules:

```yaml
post_plan_all_modules:
  <<: *firefly_agent
  stage: post-plan
  script:
    - |
      for module_dir in */; do
        module=$(basename "$module_dir")
        if [ -f "$module_dir/plan_log.jsonl" ]; then
          echo "Processing $module..."
          cd "$module_dir"
          fireflyci post-plan \
            -l plan_log.jsonl \
            -f plan_output.json \
            -i init_log.jsonl \
            --plan-output-raw-log-file plan_output_raw.log \
            --workspace "${CI_PROJECT_NAME}" \
            --environment "$module" \
            --terragrunt-version "${TERRAGRUNT_VERSION}"
          cd ..
        fi
      done
  dependencies:
    - plan_all
  only:
    - branches
    - merge_requests
```

This approach automatically processes all modules without needing separate jobs for each.

## Troubleshooting

### Error: "Firefly credentials not set"

**Cause**: The `FIREFLY_ACCESS_KEY` or `FIREFLY_SECRET_KEY` variables are not configured.

**Solution**: 
1. Go to **Settings > CI/CD > Variables**
2. Add both variables as protected and masked
3. Retry the job

### Error: "fireflyci: command not found"

**Cause**: The Firefly agent image is not accessible or the wrong image is specified.

**Solution**: 
1. Verify the image URL in `.gitlab-ci.yml`
2. Ensure your GitLab runner can pull from `public.ecr.aws`
3. Check if there are network restrictions

### Error: "plan_log.jsonl not found"

**Cause**: The wrapper script didn't generate logs, or the plan job failed.

**Solution**:
1. Check that the `plan_all` job completed successfully
2. Verify artifacts were saved from the plan job
3. Check the `dependencies:` in the post-plan job

### Logs Show "Terragrunt version: unknown"

**Cause**: The Firefly agent container does not include Terragrunt, so it cannot detect the version by itself.

**Behavior in this repo**: `.gitlab-ci.yml` sets `TERRAGRUNT_VERSION` (default: `0.51.8`) and passes it to the agent via `--terragrunt-version "${TERRAGRUNT_VERSION}"` in all post-plan/post-apply jobs. This makes the version appear correctly in Firefly even though the agent image lacks Terragrunt.

**Solution**:
1. Ensure `TERRAGRUNT_VERSION` is defined in CI (it already is in this repo).
2. Override `TERRAGRUNT_VERSION` per pipeline/job if you change Terragrunt.
3. If not set, the agent will show "unknown" but still works.

### Error: "unknown command 'sh' for 'fireflyci'"

**Cause**: The Firefly Docker image needs the correct entrypoint to run shell commands.

**Solution**: Ensure the `.firefly_agent` template includes:
```yaml
.firefly_agent: &firefly_agent
  image:
    name: public.ecr.aws/firefly/fireflyci:v0.5.149
    entrypoint: ["/bin/sh", "-c"]  # ‚Üê This is required!
  # ... rest of configuration
```

### Error: "fireflyci: not found"

**Cause**: The `fireflyci` binary is not available in the container.

**Solution**: The `.firefly_agent` template downloads the binary directly:
```yaml
before_script:
  - apk add --no-cache curl
  - curl -O https://gofirefly-prod-iac-ci-cli-binaries.s3.amazonaws.com/fireflyci/latest/fireflyci_Linux_x86_64.tar.gz
  - tar -xf fireflyci_Linux_x86_64.tar.gz
  - chmod +x fireflyci
  - mv fireflyci /usr/local/bin/
  - fireflyci version || echo "fireflyci binary ready"
```

## Benefits

Using the Firefly agent provides:

- **üìä Visibility**: Track all infrastructure changes in one place
- **üîç Drift Detection**: Detect configuration drift across modules
- **üìà Analytics**: Gain insights into infrastructure trends
- **‚úÖ Compliance**: Maintain audit trails of all changes
- **üö® Alerting**: Get notified of important infrastructure events
- **üè∑Ô∏è Tagging**: Organize resources by environment/module

## Security Considerations

1. **Credentials**: Always use GitLab's masked and protected variables
2. **Network**: The agent needs outbound HTTPS access to Firefly's API
3. **Data**: Logs containing sensitive information are sent to Firefly
4. **Access**: Control who can trigger `apply_all` (post-processing follows automatically)

## Reference

- **Firefly Documentation**: [https://docs.gofirefly.io/](https://docs.gofirefly.io/)
- **Agent CLI Reference**: See Docker image documentation
- **Wrapper Script**: `scripts/ci-tg-example/README.md`
- **GitLab CI Config**: `.gitlab-ci.yml`

---

**Need Help?** Check the Firefly documentation or contact Firefly support for agent-specific issues.

